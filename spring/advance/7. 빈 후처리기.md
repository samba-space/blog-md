# 빈 후처리기
빈 후처리기에 대해 알아보자

## 빈 후처리기란?(BeanPostProcessor)
빈 후처리기는 스프링이 빈 저장소에 등록할 목적으로 생성한 객체를 빈 저장소에 등록하기 직전에 조작할 수 있다.

## 빈 후처리기 기능
빈 처리기는 빈을 조작하고 변경할 수 있는 후킹 포인트다. 객체를 조작할 수도 있고(해당 객체의 특정 메서드 호출), 완전히 다른 객체로 바꿔치기 하는 것도 가능하다.  

일반적으로 스프링 컨테이너가 등록하는 빈들(컴포넌트 스캔의 대상이 되는 빈들)은 중간에 조작할 방법이 없는데, 빈 후처리기를 사용하면 개발자가 등록하는 모든 빈을 중간에 조작할 수 있다. 즉 빈 객체를 프록시로 교체하는 것도 가능하다.

## 빈 후처리기 과정
그림
1. 스프링 빈 대상이 되는 객체를 생성한다(@Bean, 컴포넌트 스캔)
2. 빈 저장소에 등록하기 직전에 빈 후처리기에 전달한다.
3. 빈 후처리기가 빈 객체를 조작하거나 바꿔치기 작업을 한다.
4. 빈 후처리기가 빈을 반환하여 스프링 빈 저장소에 등록된다.

## BeanPostProcessor 인터페이스 (스프링 제공)
```java
public interface BeanPostProcessor {
	Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;
	Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;
}
```
빈 후처리기를 사용하려면 BeanPostProcessor 인터페이스를 구현하고, 스프링 빈으로 등록해야 한다.  
참고로 각 메서드는 객체 생성 이후에 @PostConstruct 같은 초기화가 발생하기 전 또는 후에 호출되는 포스트 프로세서이다.
### 빈 후처리기 예제 코드
그림
빈 후처리기를 통해 A 객체를 B 객체로 바꿔치기 해보자.

우선 아래와 같이 BeanPostProcessor 인터페이스를 구현한다.

```java
@Slf4j
class AToBPostProcessor implements BeanPostProcessor {

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        log.info("beanName={} bean={}", beanName, bean);
        if (bean instanceof A) {
            return new B();
        }
        return bean;
    }
}
```

그리고 프로세서를 스프링 빈으로 등록해준다. 그러면 스프링 컨테이너가 빈 후처리기로 인식하고 동작한다.

```java
@Configuration
class BeanPostProcessorConfig {
    @Bean(name = "beanA")
    public A a() {
        return new A();
    }

    @Bean
    public AToBPostProcessor aToBPostProcessor() {
        return new AToBPostProcessor();
    }
}
```

프로세서에서 A타입이 오면 B로 바꿔치기 하기 때문에 테스트코드에서 bean Name을 beanA로 지정하여도 B가 리턴된다. 즉 A객체 대신에 B객체가 등록된 것을 확인할 수 있다.

```java
@Test
void basicConfig() {
    ApplicationContext applicationContext = new AnnotationConfigApplicationContext(BeanPostProcessorConfig.class);

    B b = applicationContext.getBean("beanA", B.class);
    b.helloB();

    Assertions.assertThrows(NoSuchBeanDefinitionException.class, () -> applicationContext.getBean(A.class));
}
```
