# 디폴트 메서드(Default Method)
자바 8에는 디폴트 메서드가 등장했다. 이번에는 디폴트 메서드가 등장한 배경과 디폴트 메서드에 대해 알아보자.

## 기존 인터페이스 변경 문제점
디폴트 메서드가 없던 시절에는 인터페이스에 메서드를 추가하면 몇가지 문제가 발생한다.  

첫번째로 인터페이스를 구현하는 기존 모든 클래스들이 해당 메서드를 구현해야 했다.  
참고로 인터페이스에 새로운 메서드를 추가하면 **바이너리 호환성**은 유지된다. 바이너리 호환성이란 새로 추가된 메서드를 호출하지만 않으면 인터페이스를 구현한 클래스에서 추가된 메서드를 구현하지 않아도 기존 클래스 파일이 잘 동작한다는 의미이다. 그러나 호출하게되면 런타임 에러가 발생한다.  

두번째로 메서드가 추가된 인터페이스를 구현한 클래스를 포함한 전체 애플리케이션을 재빌드할 때 컴파일 에러가 발생한다.

이러한 문제들을 해결하기 위해 자바 8에서는 구현을 포함하는 인터페이스를 정의하는 두가지 방법을 제공한다.   
인터페이스 내부에 **정적 메서드**를 사용하는것과 **디폴트 메서드** 기능을 사용하는 것이다. 
결과적으로 인터페이스를 구현하는 클래스들은 자동으로 인터페이스에 추가된 디폴트 메서드를 상속받게 된다.

### 정적 메서드와 인터페이스
보통 자바에서는 인터페이스와 인터페이스의 인스턴스를 활용할 수 있는 다양한 정적 메서드를 정의하는 유틸리티 클래스를 활용한다. 예를 들어 Collections는 Collection 객체를 활용할 수 있는 유틸리티 클래스다.  
자바 8에서는 인터페이스에 직접 정적 메서드를 선언할 수 있으므로 유틸리티 클래스를 더이상 만들 필요가 없다.(구버전과 호환성을 위해 자바 API에는 유틸리티 클래스가 남아있다.)

### 바이너리 호환성, 소스 호환성, 동작 호환성
간단하게 뭔가를 바꾼 이후에도 에러 없이 기존 바이너리가 실행될 수 있는 상황을 **바이너리 호환성**이라고 한다.  
**소스 호환성**이란 코드를 고쳐도 기존 프로그램을 성공적으로 재컴파일할 수 있음을 의미한다.  
**동작 호환성**이란 코드를 바꾼 다음에도 같은 입력값이 주어지면 프로그램이 같은 동작을 실행한다는 의미이다.
<br/>

## 디폴트 메서드란 무엇인가?
앞서 살펴본 것과 같이 문제점들이 있고, 이를 해결하기 위해 자바 8에서는 호환성을 유지하면서 API를 바꿀 수 있도록 새로운 기능인 **디폴트 메서드**를 제공한다.

아래와 같이 디폴트 메서드는 ``default``라는 키워드로 시작하고, 클래스의 메서드처럼 바디를 포함한다.  
이제 Sized 인터페이스를 구현하는 모든 클래스는 isEmpty의 구현도 상속받는다. 즉, 소스호환성이 유지된다.

```java
public interface Sized {
    int size();
    default boolean isEmpty() {
        return size() == 0;
    }
}
```
> ##### 추상클래스와 자바 8의 인터페이스의 차이점
##### 1. 클래스는 하나의 추상 클래스만 상속받을 수 있지만 인터페이스는 여러개 구현가능한다.  
##### 2. 둘째 추상 클래스는 인스턴스 변수를 가질 수 있고, 인터페이스는 그렇지 못하다.

<br/>

## 디폴트 메서드 활용 패턴
디폴트 메서드를 이용하는 두가지 방식 **선택형 메서드**와 **동작 다중 상속**에 대해 알아보자.

### 1. 선택형 메서드(optional method)
자바 8 이전에 ``Iterator`` 인터페이스를 구현한 많은 클래스들은 remove 기능을 잘 사용하지 않아, remove에 빈 구현을 제공했다. 디폴트 메서드를 이용하면 메서드에 기본 구현을 제공할 수 있으므로 구현 클래스에서 빈 구현을 제공할 필요가 없어진다. **즉 불필요한 코드를 줄일 수 있다.**

```java
interface Iterator<T> {
    boolean hasNext();
    T next();
    default void remove() {
        throw new UnsupportedOperationException();
    }
}
```

위처럼 자바 8의 ``Iterator`` 인테페이스에서 remove 메서드를 디폴트 메서드로 구현하여, 기본 구현을 제공한다.

### 2. 동작 다중 상속(multiple inheritance of behavior)
디폴트 메서드를 이용하면 기존에는 불가능했던 동작 다중 상속 기능도 구현할 수 있다. 자바 8에서는 인터페이스가 구현을 포함할 수 있으므로 동작(구현 코드)을 상속받을 수 있다.

아래처럼 다중 상속은 디폴트 메서드와 관계 없이 활용할 수 있다.

```java
public class ArrayList<\E> extends AbstractList<\E>
    implements List<\E>, RandomAccess, Clonable, Serializable {
    }
```

`ArrayList`는 한개의 클래스를 상속, 여섯개의 인터페이스를 구현했다. `AbstractList`, `List` 등 7개의 타입의 서브타입이 된다. 즉, 디폴트 메서드를 사용하지 않아도 다중 상속을 활용할 수 있다. 

### 동작 다중 상속의 장점
동작 다중 상속의 장점은 기능이 중복되지 않는 최소의 인터페이스들을 활용하여, 코드를 복붙할 필요 없이 디폴트 메서드를 재사용할 수 있다.

``Rotatable``과 ``Moveable`` 인터페이스를 정의하였다. 각 인터페이스는 디폴트 메서드를 제공하고 있다.

```java
public interface Rotatable {
    void setRotationAngle(int angleInDegrees);
    int getRotationAngle();
    default void rotateBy(int angleInDegrees){
        setRotationAngle((getRotationAngle() + angleInDegrees) % 360);
    }
}
```
```java
public interface Moveable {
    int getX();
    int getY();
    void setX(int x);
    void setY(int y);

    default void moveHorizontally(int distance) {
        setX(getX() + distance);
    }

    default void moveVertically(int distance) {
        setY(getY() + distance);
    }
}
```

이제 회전하고 움직일 수 있는 ``Monster`` 클래스를 정의해보자.

```java
public class Monster implements Rotatable, Moveable {
    // 추상메서드 구현
}
```

``Monster``는 구현한 인터페이스들의 디폴트 메서드를 자동으로 상속받는다. 상속받은 다양한 메서드는 직접 호출할 수 있다.

```java
Monster monster = new Monster();
monster.rotateBy(180);
monster.moveVertically(10);
```

이번에는 회전만 할 수 있는 ``Sun`` 클래스를 정의했다. 디폴트 메서드를 재사용하여, 코드 복붙을 할 필요가 없어졌다.

```java
public class Sun implements Rotatable {
    //추상메서드 구현
}
```

인터페이스에 구현을 포함시키면 또 다른 장점은 디폴트 메서드를 직접 수정할 수 있으므로, 해당 인터페이스를 구현한 모든 클래스에 자동으로 변경한 코드가 상속된다는 것이다.

> #### 한개의 메서드를 재사용하려고 수많은 필드와 메서드가 정의되어 있는 클래스를 상속 받는것은 옳지 못하다. 이럴 경우 delegation, 즉 멤버 변수를 이용해서 필요한 메서드를 직접 호출하는 메서드를 작성하는 것이 좋다.

<br/>

## 해결 규칙
자바 8에는 디폴트 메서드가 추가되었으므로 같은 시그니처를 갖는 디폴트 메서드를 상속받는 상황이 생길수 있다.  
자바 8은 이러한 문제에 대한 해결 규칙을 제공한다.

다른 클래스나 인터페이스로부터 같은 시그니처를 갖는 메서드를 상속받을 때 세가지 규칙을 따라야 한다.
1. 클래스가 항상 이긴다. 클래스나 슈퍼클래스에서 정의한 메서드가 디폴트 메서드보다 우선권을 갖는다.
2. 1번 규칙 이외의 상황에서는 서브인터페이스가 이긴다. 상속관계를 갖는 인터페이스에서 같은 시그니처를 갖는 메서드를 정의할 때는 서브인터페이스가 이긴다.
3. 여전히 디폴트 메서드의 우선순위가 결정되지 않았다면 여러 인터페이스를 상속받는 클래스가 명시적으로 디폴트 메서드를 오버라이드하고 호출해야 한다.
    - 자바 8에서 X.super.m() 형태의 새로운 문법을 제공하며, X는 m메서드의 슈퍼인터페이스다.
<br/>

## 참고
- modern java in action
