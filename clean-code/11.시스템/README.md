# 시스템

## 확장
- 처음부터 올바르게 시스템을 만들 수 있다는 믿음은 미신이다. 대신에 우리는 오늘 주어진 사용자 스토리에 맞춰 시스템을 구현해야 한다. 내일은 새로운 스토리에 맞춰 시스템을 조정하고 확장하면 된다. 이것이 반복적이고 점진적인 애자일 방식의 핵심이다.
- TDD, 리팩터링, 그로인해 얻어지는 깨끗한 코드는 코드 수준에서 시스템을 조정하고 확장하기 쉽게 만든다.
- 소프트웨어 시스템은 물리적인 시스템과 다르다. 관심사를 적절히 분리해 관리한다면 소프트웨어 아키텍처는 점진적으로 발전할 수 있다.(적절히 분리하지 못한 예: EJB1, 2)
### 횡단(cross-cutting) 관심사
- 영속성과 같은 관심사는 애플리케이션의 자연스러운 객체 경계를 넘나드는 경향이 있다. 모든 객체가 전반적으로 동일한 방식을 이용하게 만들어야 한다.
- 원론적으로는 모듈화되고 캡슐화된 방식으로 구현한 코드가 온갖 객체로 흩어진다. 여기서 횡단 관심사라는 용어가 나온다. 영속성 프레임워크, 도메인 논리 모두 모듈화할 수 있지만 문제는 두 영역이 세밀한 단위로 겹친다는 점이다.
- AOP는 횡단 관심사에 대처해 모듈성을 확보하는 일반적인 방법론이다. AOP에서 관점(aspect)이라는 모듈 구성 개념은 "특정 관심사를 지원하려면 시스템에서 특정 지점들이 동작하는 방식을 일관성 있게 바꿔야 한다"라고 명시한다. 
    - 영속성을 예로 들면, 프로그래머는 영속적으로 저장할 객체와 속성을 선언한 후 영속성 책임을 영속성 프레임워크에 위임한다. 그러면 AOP 프레임워크는 대상 코드에 영향을 미치지 않는 상태로 동작 방식을 변경한다.

## 자바에서 사용하는 관점 혹은 유사한 메커니즘 3가지
### 1. 자바 프록시
- 자바 프록시는 단순한 상황에 적합하다. 개별 객체나 클래스에서 메서드 호출을 감싸는 경우가 좋은 예다.
- JDK에서 제공하는 동적 프록시는 인터페이스만 지원한다. 클래스 프록시는 CGLIB, ASM, Javassist등과 같은 바이트 코드 처리 라이브러리가 필요하다.
- 프록시의 단점 2가지는 코드 양과 크기이다. 프록시를 사용하면 깨끗한 코드를 작성하기 어렵다. 또한 프록시는 진정한 AOP 해법에 필요한 시스템 단위로 실행 지점을 명시하는 메커니즘도 제공하지 않는다.
    - 흔히 메서드 가로채기, 프록시를 통한 감싸기 등의 AOP를 구현하는 기법과 AOP 자체를 혼동한다. AOP 시스템의 진정한 가치는 시스템 동작을 간결하고 모듈화된 방식으로 명시하는 능력이다.

### 2. 순수 자바 AOP 프레임워크
- 대부분의 프록시 코드는 비슷하여 도구로 자동화할 수 있다. 순수 자바 관점을 구현하는 스프링 AOP, JBoss AOP 등과 같은 여러 자바 프레임워크는 내부적으로 프록시를 사용한다.

### 3. AspectJ 관점
- 관심사를 관점으로 분리하는 가장 강력한 도구는 AspectJ언어다. AspectJ는 관점을 분리하는 강력하고 풍부한 도구 집합을 제공하긴 하지만, 새 도구를 사용하고 새 언어 문법과 사용법을 익혀야 한다는 단점이 있다.

## 테스트 주도 시스템 아키텍처 구축
- 관점 혹은 유사한 개념으로 관심사를 분리하는 방식은 그 위력이 막강하다. 애플리케이션 도메인 논리를 POJO로 작성할 수 있다면, 즉 코드 수준에서 아키텍처 관심사를 분리할 수 있다면, 진정한 테스트 주도 아키텍처 구축이 가능해진다. 그때 그때 새로운 기술을 채택해 단순한 아키텍처를 복잡한 아키텍처로 키워갈 수도 있다.
- 소프트웨어 구조가 관점을 효과적으로 분리한다면, 극적인 변화가 경제적으로 가능하다. 설계가 최대한 분리되어 각 추상화 수준과 범위에서 코드가 적당히 단순하기 때문이다.
- 초창기 EJB 아키텍처는 기술을 너무 많이 넣느라 관심사를 제대로 분리하지 못했던 유명한 API 중 하나다.

## 의사 결정을 최적화하라
- 모듈을 나누고 관심사를 분리하면 지엽적인 관리와 결정이 가능해진다. 가능한 마지막 순간까지 결정을 미루는 방법이 최선이다. 왜냐하면 최대한 정보를 모아 최선의 결정을 내리기 위해서다.
- 관심사를 모듈로 분리한 POJO 시스템은 기민함을 제공한다. 이런 기민함 덕택에 최신 정보에 기반해 최선의 시점에 최적의 결정을 내리기가 쉬워진다. 또한 결정의 복잡성도 줄어든다.

## 명백한 가치가 있을 때 표준을 현명하게 사용하라
- 가볍고 간단한 설계로 충분했을 프로젝트에서도 단지 표준이라는 이유만으로 EJB2를 많은 팀이 사용했다. 업계에서 여러 형태로 아주 과장되게 포장된 표준에 집착하는 바람에 고객 가치가 뒷전으로 밀려난 사례가 많다.

## 시스템은 도메인 특화 언어가 필요하다
- 소프트웨어 분야에서도 최근 들어 DSL이 새롭게 조명 받기 시작했다. DSL은 간단한 스크립트 언어나 표준 언어로 구현한 API를 가리킨다. 
- 좋은 DSL은 도메인 개념과 그 개념을 구현한 코드 사이에 존재하는 의사소통 간극을 줄여준다. 도메인 전문가가 사용하는 언어로 도메인 논리를 구현하면 도메인을 잘못 구현할 가능성이 줄어든다.
- 효과적으로 사용한다면 DSL은 추상화 수준을 코드 관용구나 디자인 패턴 이상으로 끌어올린다. 그래서 개발자가 적절한 추상화 수준에서 코드 의도를 표현할 수 있다.

## 결론
- 시스템 역시 깨끗해야 한다. 깨끗하지 못한 아키텍처는 도메인 논리를 흐리며 기민성을 떨어뜨린다. 
- 모든 추상화 단계에서 의도는 명확히 표현해야 한다. 그러려면 POJO를 작성하고 관점 혹은 관점과 유사한 메커니즘을 사용해 각 구현 관심사를 분리해야한다.